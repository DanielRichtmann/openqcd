
/*******************************************************************************
*
* File dfl_sap_gcr.c
*
* Copyright (C) 2007, 2011, 2012 Martin Luescher
*
* This software is distributed under the terms of the GNU General Public
* License (GPL)
*
* SAP+GCR solver for the Wilson-Dirac equation with local deflation
*
* The externally accessible functions are
*
*   double dfl_sap_gcr(int nkv,int nmx,double res,double mu,
*                      spinor_dble *eta,spinor_dble *psi,int *status)
*     Obtains an approximate solution psi of the Wilson-Dirac equation for
*     given source eta using the deflated SAP-preconditioned GCR algorithm.
*     See the notes for the explanation of the parameters of the program.
*
*   double dfl_sap_gcr2(int nkv,int nmx,double res,double mu,
*                       spinor_dble *eta,spinor_dble *psi,int *status)
*     This program calls dfl_sap_gcr() with the parameters nkv,..,status.
*     If the solver fails and status[0]=-3 or status[0]>=0 and status[1]<0
*     or status[2]<0, the deflation subspace is regenerated by calling
*     dfl_modes(). The solver program dfl_sap_gcr() is then called again
*     and the results are passed to the calling program.
*
* Depending on whether the twisted-mass flag is set or not, the programs
* solve the equation
*
*   (Dw+i*mu*gamma_5*1e)*psi=eta  or  (Dw+i*mu*gamma_5)*psi=eta
*
* respectively. The twisted-mass flag is retrieved from the parameter data
* base (see flags/lat_parms.c).

* The program dfl_sap_grc() is based on the flexible GCR algorithm (see
* linsolv/fgcr.c). Before the solver is launched, the following parameter-
* setting programs must have been called:
*
*  set_lat_parms()        Improvement coefficients.
*
*  set_sw_parms()         Bare quark mass.
*
*  set_sap_parms()        Parameters of the SAP preconditioner.
*
*  set_dfl_parms()        Parameters of the deflation subspace.
*
*  set_dfl_pro_parms()    Parameters to be passed to the deflation
*                         projectors.
*
* See the corresponding files modules/flags directory for further explanations.
* The deflation subspace must have been properly initialized by the program
* dfl_subspace().
*
* All other parameters are passed through the argument list:
*
*  nkv       Maximal number of Krylov vectors generated before the GCR
*            algorithm is restarted.
*
*  nmx       Maximal total number of Krylov vectors that may be generated.
*
*  res       Desired maximal relative residue |eta-D*psi|/|eta| of the
*            calculated solution.
*
*  mu        Value of the twisted mass in the Dirac equation.
*
*  eta       Source field. Note that source fields must vanish at global 
*            time 0 and NPR0C0*L0-1, as has to be the case for physical
*            quark fields. eta is unchanged on exit unless psi=eta (which
*            is permissible).
*
*  psi       Calculated approximate solution of the Dirac equation. psi
*            vanishes at global time 0 and NPROC0*L0-1.
*
* The argument status must point to an array of at least 3 and 4 integers,
* respectively, in the case of the programs dfl_sap_gcr() and dfl_sap_gcr2().
* On exit, the array elements contain the following values:
*
*  status[0] If the program is able to solve the Dirac equation to the
*            desired accuracy, status[0] reports the total number of Krylov
*            vectors that were required for the solution. Negative values
*            indicate that the program failed (-1: the algorithm did not
*            converge, -2: the inversion of the SW term on the odd points
*            was not safe, -3: the inversion of the diagonal parts of the
*            little Dirac operator was not safe). 
*
*  status[1] Average number of GCR iterations needed for the solution of 
*            the little Dirac equation when the double-precision deflation
*            projector RLpro_dble() is applied.
*
*  status[2] Average number of GCR iterations needed for the solution of 
*            the little Dirac equation when the single-precision deflation
*            projector RLpro() is applied.
*
*  status[3] Average solver iteration numbers that were required for the
*            solution of the little Dirac equation when the deflation sub-
*            space had to be regenerated (if the regeneration fails, the
*            dfl_sap_gcr2() program terminates with an error message).
*
* If status[0]>=-1, status[1]>=0 and status[2]>=0, the programs return
* the norm of the calculated approximate solution. Otherwise the field
* psi is set to zero and the program returns the norm of the source eta.
*
* The SAP_BLOCKS blocks grid is automatically allocated or reallocated if
* it is not already allocated with the correct block size. The SW term is
* recalculated when needed and the gauge and SW fields are copied to the
* SAP block grid if they are not in the proper condition. Similarly, the
* little Dirac operator is updated when needed.
*
* The program dfl_sap_gcr2() can be used in place of dfl_sap_gcr() if some
* protection against the rare cases, where the little Dirac operator turns
* out to be accidentally ill-conditioned, is desired.
*
* Evidently the SAP+GCR solver is a global program that must be called on
* all processes simultaneously. The required workspaces are
*
*  spinor              2*nkv+1
*  spinor_dble         4              [3 in the case of dfl_sap_gcr()]
*  complex             2*nkv_pro+2
*  complex_dble        4
*
* (see utils/wspace.c), where nkv_pro, the maximal number of Krylov vectors
* generated before the GCR solver of the little Dirac equation is restarted,
* is a parameter set by dfl_pro_parms().
*
*******************************************************************************/

#define DFL_SAP_GCR_C

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "mpi.h"
#include "utils.h"
#include "flags.h"
#include "block.h"
#include "uflds.h"
#include "sflds.h"
#include "linalg.h"
#include "sw_term.h"
#include "dirac.h"
#include "linsolv.h"
#include "sap.h"
#include "little.h"
#include "dfl.h"
#include "global.h"

static int nit[2],stat[2];
static double mud,nrm;
static double nrm0,nrm1,res0,res1;
static sap_parms_t spr;
static dfl_pro_parms_t dpr;


static void Dop(spinor_dble *s,spinor_dble *r)
{
   int status;
   
   Dw_dble(mud,s,r);
   dfl_RLpro_dble(dpr.nkv,dpr.nmx,res0,mud,s,r,&status);

   if (stat[0]>=0)
   {
      if (status>=0)
      {
         nit[0]+=1;
         stat[0]+=status;
      }
      else 
         stat[0]=status;
   }
}


static void Mop(int k,spinor *rho,spinor *phi,spinor *chi)
{
   int n,status;
   
   set_s2zero(VOLUME,phi);
   assign_s2s(VOLUME,rho,chi);
   nrm1=sqrt((double)(norm_square(VOLUME,1,rho)));

   if (k==0)
   {
      nrm0=nrm1;

      if ((nrm0<nrm)&&(nrm0>0.0))
      {
         res0=dpr.resd*nrm/nrm0;

         if (res0>1.0e-3)
            res0=1.0e-3;
      }
      else
         res0=dpr.resd;

      res1=dpr.res;
   }
   else if ((nrm1<nrm0)&&(nrm1>0.0))
   {
      res1=dpr.res*nrm0/nrm1;

      if (res1>1.0e-2)
         res1=1.0e-2;
   }

   for (n=0;n<spr.ncy;n++)
      sap((float)(mud),spr.isolv,spr.nmr,phi,chi);

   diff_s2s(VOLUME,rho,chi);
   dfl_RLpro(dpr.nkv,dpr.nmx,res1,mud,phi,chi,&status);

   if (stat[1]>=0)
   {
      if (status>=0)
      {
         nit[1]+=1;
         stat[1]+=status;
      }
      else
         stat[1]=status;
   }
}


double dfl_sap_gcr(int nkv,int nmx,double res,double mu,
                   spinor_dble *eta,spinor_dble *psi,int *status)
{
   int nb,isw,ifail;
   int swde,swdo,swu,swe,swo;
   double rho,rho0,fact;
   spinor **ws;
   spinor_dble **rsd,**wsd;

   spr=sap_parms();
   error_root(spr.ncy==0,1,"dfl_sap_gcr [dfl_sap_gcr.c]",
              "SAP parameters are not set");
   dpr=dfl_pro_parms();
   error_root(dpr.nkv==0,1,"dfl_sap_gcr [dfl_sap_gcr.c]",
              "Deflation projector parameters are not set");

   blk_list(SAP_BLOCKS,&nb,&isw);

   if (nb==0)
      alloc_bgr(SAP_BLOCKS);
   
   if (query_grid_flags(SAP_BLOCKS,UBGR_MATCH_UD)!=1)
      assign_ud2ubgr(SAP_BLOCKS);

   if (query_flags(SWD_UP2DATE)!=1)
      sw_term(NO_PTS);

   swde=query_flags(SWD_E_INVERTED);
   swdo=query_flags(SWD_O_INVERTED);
   
   swu=query_grid_flags(SAP_BLOCKS,SW_UP2DATE);
   swe=query_grid_flags(SAP_BLOCKS,SW_E_INVERTED);
   swo=query_grid_flags(SAP_BLOCKS,SW_O_INVERTED);
   ifail=0;

   if (spr.isolv==0)
   {
      if ((swde==1)||(swdo==1))
         sw_term(NO_PTS);

      if ((swu!=1)||(swe==1)||(swo==1))
         assign_swd2swbgr(SAP_BLOCKS,NO_PTS);
   }
   else if (spr.isolv==1)
   {
      if ((swde!=1)&&(swdo==1))
      {
         if ((swu!=1)||(swe==1)||(swo!=1))
            assign_swd2swbgr(SAP_BLOCKS,NO_PTS);

         sw_term(NO_PTS);
      }
      else
      {
         if ((swde==1)||(swdo==1))
            sw_term(NO_PTS);

         if ((swu!=1)||(swe==1)||(swo!=1))
            ifail=assign_swd2swbgr(SAP_BLOCKS,ODD_PTS);
      }
   }
   else
      error_root(1,1,"dfl_sap_gcr [dfl_sap_gcr.c]","Unknown block solver");
   
   if (query_flags(U_MATCH_UD)!=1)
      assign_ud2u();

   if ((query_flags(SW_UP2DATE)!=1)||
       (query_flags(SW_E_INVERTED)==1)||(query_flags(SW_O_INVERTED)==1))
      assign_swd2sw();
   
   rsd=reserve_wsd(2);   
   rho0=sqrt(norm_square_dble(VOLUME,1,eta));
   rho=rho0;
   status[0]=0;
   status[1]=0;
   status[2]=0;
   
   if (ifail)
      status[0]=-2;
   else
   {
      ifail=set_Awhat(mu);

      if (ifail)
         status[0]=-3;
      else      
      {
         nit[0]=0;
         nit[1]=0;
         stat[0]=0;
         stat[1]=0;

         mud=mu;
         res0=dpr.resd;
         res1=dpr.res;
         fact=rho0/sqrt((double)(VOLUME)*(double)(24*NPROC));

         if (fact!=0.0)
         {
            assign_sd2sd(VOLUME,eta,rsd[0]);            
            scale_dble(VOLUME,1.0/fact,rsd[0]);
            dfl_Lpro_dble(dpr.nkv,dpr.nmx,dpr.resd,mu,rsd[0],rsd[1],stat);
            
            if (stat[0]>=0)
            {
               nit[0]+=1;
               nrm=norm_square_dble(VOLUME,1,rsd[0]);
               nrm=sqrt(nrm);
               res*=(rho0/(fact*nrm));

               ws=reserve_ws(2*nkv+1);
               wsd=reserve_wsd(1);
               rho=fgcr(VOLUME,1,Dop,Mop,ws,wsd,nkv,nmx,res,rsd[0],psi,status);
               release_wsd();
               release_ws();

               mulr_spinor_add_dble(VOLUME,psi,rsd[1],1.0);
               scale_dble(VOLUME,fact,psi);
               rho*=fact;
            }
         }
         else
         {
            rho=0.0;
            set_sd2zero(VOLUME,psi);
         }
         
         if ((nit[0]>0)&&(stat[0]>=0))
            status[1]=(stat[0]+nit[0]/2)/nit[0];
         else if (stat[0]<0)
            status[1]=stat[0];
         
         if ((nit[1]>0)&&(stat[1]>=0))
            status[2]=(stat[1]+nit[1]/2)/nit[1];
         else if (stat[1]<0)
            status[2]=stat[1];
      }
   }

   if ((status[0]<-1)||(status[1]<0)||(status[2]<0))
   {
      rho=rho0;
      set_sd2zero(VOLUME,psi);
   }

   release_wsd();
   
   return rho;
}


double dfl_sap_gcr2(int nkv,int nmx,double res,double mu,
                    spinor_dble *eta,spinor_dble *psi,int *status)
{
   double rho;
   spinor_dble **wsd;

   wsd=reserve_wsd(1);

   if (eta==psi)
   {
      assign_sd2sd(VOLUME,eta,wsd[0]);
      eta=wsd[0];
   }
   
   rho=dfl_sap_gcr(nkv,nmx,res,mu,eta,psi,status);

   if ((status[0]==-3)||((status[0]>=0)&&((status[1]<0)||(status[2]<0))))
   {
      dfl_modes(status+3);

      error_root(status[3]<0,1,"dfl_sap_gcr2 [dfl_sap_gcr.c]",
                 "Deflation subspace regeneration failed (status = %d)",
                 status[3]);

      rho=dfl_sap_gcr(nkv,nmx,res,mu,eta,psi,status);
   }
   else
      status[3]=0;

   release_wsd();
   
   return rho;
}
